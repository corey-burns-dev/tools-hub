---
import Button from "@/components/ui/Button.astro";
import memesData from "../data/memes.json";
import Layout from "../layouts/Layout.astro";
---

<Layout title="Meme Generator">
  <div class="meme-page">
    <div
      id="meme-generator-container"
      class="meme-layout"
      data-memes={JSON.stringify(memesData)}
    >
      <!-- Left: Controls Panel -->
      <div class="controls-panel">
        <!-- Unified Settings Card -->
        <div class="controls-card">
          <!-- Tab Navigation -->
          <div class="tab-bar">
            <button id="tab-image" class="meme-tab active">
              Image Source
            </button>
            <button id="tab-text" class="meme-tab">
              Text Boxes
            </button>
          </div>

          <!-- Tab Content Area -->
          <div class="tab-body custom-scrollbar">
            <!-- Image Source Tab -->
            <div id="content-image" class="tab-content">
              <div class="upload-row">
                <input
                  type="file"
                  id="image-upload"
                  accept="image/*"
                  class="file-input"
                />
                <Button id="refresh-memes" variant="ghost" size="sm" class="refresh-btn">
                  Refresh
                </Button>
              </div>

              <input
                type="text"
                id="meme-search"
                placeholder="Search templates..."
                class="search-input"
              />

              <!-- Loading State -->
              <div id="memes-loading" class="loading-state">
                <div class="spinner"></div>
                <span>Loading...</span>
              </div>

              <!-- Memes Grid -->
              <div style="display:none" id="memes-grid-wrapper">
                <div class="memes-grid custom-scrollbar" id="memes-grid"></div>
              </div>
            </div>

            <!-- Text Boxes Tab -->
            <div id="content-text" class="tab-content hidden">
              <div class="text-tab-header">
                <span class="text-xs font-semibold text-slate-400">Text Boxes</span>
                <div class="flex gap-1.5">
                  <Button id="reset-text-boxes" variant="ghost" size="sm" class="h-6 text-[10px]">
                    Reset
                  </Button>
                  <Button id="add-text-box" variant="primary" size="sm" class="h-6 text-[10px]">
                    + Add
                  </Button>
                </div>
              </div>
              <div id="text-boxes-container" class="text-boxes-list"></div>
            </div>
          </div>

          <!-- Style Settings - Always Visible -->
          <div class="style-bar">
            <div class="style-row">
              <div class="style-control">
                <label>Size</label>
                <div class="range-group">
                  <input
                    type="range"
                    id="global-font-size"
                    min="20"
                    max="100"
                    value="40"
                    class="compact-range"
                  />
                  <span id="global-font-size-value" class="range-val">40</span>
                </div>
              </div>
              <div class="style-control">
                <label>Outline</label>
                <div class="range-group">
                  <input
                    type="range"
                    id="global-stroke-width"
                    min="0"
                    max="10"
                    value="3"
                    class="compact-range"
                  />
                  <span id="global-stroke-width-value" class="range-val">3</span>
                </div>
              </div>
              <div class="style-control color-control">
                <label>Color</label>
                <input
                  type="color"
                  id="global-text-color"
                  value="#ffffff"
                  class="color-swatch"
                />
              </div>
              <button id="reset-positions" class="reset-pos-btn" title="Reset text positions">
                Reset Pos
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Right: Preview Panel -->
      <div class="preview-panel">
        <div class="preview-card">
          <div class="preview-header">
            <span class="preview-label">Preview</span>
            <div class="preview-actions">
              <Button
                id="toggle-edit-mode"
                variant="secondary"
                size="sm"
                title="Toggle drag to reposition text"
                class="h-7 text-[10px]"
              >
                Edit Mode
              </Button>
              <Button id="download-btn" variant="primary" size="sm" class="h-7 text-[10px]">
                Save
              </Button>
            </div>
          </div>
          <div id="canvas-wrapper" class="canvas-area">
            <canvas
              id="meme-canvas"
              class="meme-canvas"
            ></canvas>
            <div
              id="edit-hint"
              class="edit-hint hidden"
            >
              Drag text to reposition
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</Layout>

<style>
  /* ─── Page layout ─── */
  .meme-page {
    display: flex;
    flex-direction: column;
    height: 100%;
    padding: 0.5rem;
    overflow: hidden;
  }

  .meme-layout {
    display: grid;
    grid-template-columns: 340px 1fr;
    gap: 0.5rem;
    height: 100%;
    min-height: 0;
  }

  @media (max-width: 900px) {
    .meme-layout {
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 1fr;
    }
  }

  /* ─── Controls Panel ─── */
  .controls-panel {
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow: hidden;
  }

  .controls-card {
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0;
    border-radius: 0.75rem;
    border: 1px solid rgba(255, 255, 255, 0.06);
    background: rgba(255, 255, 255, 0.025);
    backdrop-filter: blur(20px);
    overflow: hidden;
  }

  /* ─── Tabs ─── */
  .tab-bar {
    display: flex;
    gap: 1px;
    padding: 0.375rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    flex-shrink: 0;
    background: rgba(0, 0, 0, 0.15);
  }

  .meme-tab {
    flex: 1;
    padding: 0.375rem 0.5rem;
    border-radius: 0.375rem;
    font-size: 0.6875rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: rgba(255, 255, 255, 0.35);
    background: transparent;
    border: 1px solid transparent;
    cursor: pointer;
    transition: all 0.2s;
  }

  .meme-tab:hover {
    color: rgba(255, 255, 255, 0.6);
    background: rgba(255, 255, 255, 0.04);
  }

  .meme-tab.active {
    color: white;
    background: rgba(99, 102, 241, 0.15);
    border-color: rgba(99, 102, 241, 0.25);
  }

  /* ─── Tab Content ─── */
  .tab-body {
    flex: 1;
    min-height: 0;
    overflow-y: auto;
    padding: 0.5rem;
  }

  .tab-content {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .tab-content.hidden {
    display: none;
  }

  /* ─── Image Source Tab ─── */
  .upload-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .file-input {
    flex: 1;
    font-size: 0.6875rem;
    color: rgba(255, 255, 255, 0.5);
    padding: 0 !important;
    border: none !important;
    background: transparent !important;
  }

  .file-input::file-selector-button {
    padding: 0.3rem 0.625rem;
    border-radius: 999px;
    border: none;
    background: #6366f1;
    color: white;
    font-size: 0.625rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    cursor: pointer;
    transition: background 0.2s;
    margin-right: 0.5rem;
  }

  .file-input::file-selector-button:hover {
    background: #818cf8;
  }

  :global(.refresh-btn) {
    flex-shrink: 0;
    font-size: 0.625rem !important;
  }

  .search-input {
    font-size: 0.75rem !important;
    padding: 0.35rem 0.625rem !important;
  }

  .loading-state {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 1rem;
    color: rgba(255, 255, 255, 0.35);
    font-size: 0.6875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .spinner {
    width: 1rem;
    height: 1rem;
    border: 2px solid rgba(255, 255, 255, 0.08);
    border-top-color: #6366f1;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* ─── Memes Grid ─── */
  .memes-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.375rem;
    max-height: 100%;
    overflow-y: auto;
    padding-right: 2px;
  }

  .meme-template {
    position: relative;
    aspect-ratio: 1;
    border-radius: 0.5rem;
    overflow: hidden;
    border: 2px solid rgba(255, 255, 255, 0.05);
    cursor: pointer;
    transition: all 0.2s;
  }

  .meme-template:hover {
    border-color: rgba(99, 102, 241, 0.4);
    transform: scale(1.03);
  }

  .meme-template.selected {
    border-color: #6366f1;
    box-shadow: 0 0 0 1px #6366f1, 0 4px 12px rgba(99, 102, 241, 0.25);
  }

  .meme-template img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .meme-name {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 0.75rem 0.25rem 0.25rem;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.85), transparent);
    font-size: 0.5625rem;
    font-weight: 700;
    color: white;
    text-align: center;
    opacity: 0;
    transition: opacity 0.2s;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    line-height: 1.2;
  }

  .meme-template:hover .meme-name,
  .meme-template.selected .meme-name {
    opacity: 1;
  }

  /* ─── Text Boxes Tab ─── */
  .text-tab-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .text-boxes-list {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
  }

  :global(.text-box-card) {
    background: rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 0.5rem;
    padding: 0.5rem;
    transition: all 0.2s;
  }

  :global(.text-box-card.active) {
    border-color: rgba(99, 102, 241, 0.4) !important;
    background: rgba(99, 102, 241, 0.06) !important;
  }

  /* ─── Style Bar (always visible) ─── */
  .style-bar {
    flex-shrink: 0;
    padding: 0.5rem 0.625rem;
    border-top: 1px solid rgba(255, 255, 255, 0.06);
    background: rgba(0, 0, 0, 0.2);
  }

  .style-row {
    display: flex;
    align-items: center;
    gap: 0.625rem;
  }

  .style-control {
    display: flex;
    align-items: center;
    gap: 0.375rem;
    flex: 1;
    min-width: 0;
  }

  .style-control label {
    font-size: 0.5625rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: rgba(255, 255, 255, 0.3);
    margin: 0;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .range-group {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    flex: 1;
    min-width: 0;
  }

  .compact-range {
    flex: 1;
    height: 3px !important;
    min-width: 0;
    padding: 0 !important;
    border: none !important;
    background: rgba(255, 255, 255, 0.08) !important;
  }

  .range-val {
    font-size: 0.625rem;
    font-weight: 700;
    font-family: monospace;
    color: #818cf8;
    min-width: 1.25rem;
    text-align: right;
    flex-shrink: 0;
  }

  .color-control {
    flex: 0 0 auto;
  }

  .color-swatch {
    width: 1.5rem;
    height: 1.5rem;
    border-radius: 0.375rem;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    background: transparent !important;
    padding: 1px !important;
    cursor: pointer;
  }

  .reset-pos-btn {
    flex-shrink: 0;
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    border: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(255, 255, 255, 0.04);
    color: rgba(255, 255, 255, 0.45);
    font-size: 0.5625rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }

  .reset-pos-btn:hover {
    background: rgba(255, 255, 255, 0.08);
    color: rgba(255, 255, 255, 0.7);
  }

  /* ─── Preview Panel ─── */
  .preview-panel {
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow: hidden;
  }

  .preview-card {
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0;
    border-radius: 0.75rem;
    border: 1px solid rgba(255, 255, 255, 0.06);
    background: rgba(255, 255, 255, 0.025);
    backdrop-filter: blur(20px);
    overflow: hidden;
  }

  .preview-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem 0.625rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    flex-shrink: 0;
    background: rgba(0, 0, 0, 0.1);
  }

  .preview-label {
    font-size: 0.8125rem;
    font-weight: 700;
    color: rgba(255, 255, 255, 0.9);
    font-family: "Outfit", system-ui, sans-serif;
  }

  .preview-actions {
    display: flex;
    gap: 0.375rem;
  }

  .canvas-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem;
    min-height: 0;
    position: relative;
    background: rgba(0, 0, 0, 0.25);
  }

  .meme-canvas {
    max-width: 100%;
    max-height: 100%;
    border-radius: 0.375rem;
    cursor: default;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    transition: box-shadow 0.2s;
  }

  #meme-canvas.edit-mode {
    cursor: move;
    box-shadow:
      0 0 0 2px #6366f1,
      0 12px 32px rgba(0, 0, 0, 0.5);
  }

  .edit-hint {
    position: absolute;
    top: 0.75rem;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(99, 102, 241, 0.9);
    color: white;
    padding: 0.3rem 0.75rem;
    border-radius: 999px;
    font-size: 0.6875rem;
    font-weight: 700;
    white-space: nowrap;
    pointer-events: none;
    animation: fadeInDown 0.3s ease;
  }

  .edit-hint.hidden {
    display: none;
  }

  @keyframes fadeInDown {
    from {
      opacity: 0;
      transform: translateX(-50%) translateY(-8px);
    }
    to {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  }

  /* ─── Scrollbars ─── */
  .custom-scrollbar::-webkit-scrollbar {
    width: 4px;
    height: 4px;
  }
  .custom-scrollbar::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 4px;
  }
  .custom-scrollbar::-webkit-scrollbar-thumb {
    background: rgba(99, 102, 241, 0.25);
    border-radius: 4px;
  }
  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    background: rgba(99, 102, 241, 0.45);
  }
</style>

<script>
  const container = document.getElementById("meme-generator-container");
  const memesData = JSON.parse(container?.dataset.memes || "[]");

  const canvas = document.getElementById("meme-canvas") as HTMLCanvasElement;
  const ctx = canvas.getContext("2d");
  const imageUpload = document.getElementById("image-upload") as HTMLInputElement;
  const downloadBtn = document.getElementById("download-btn");
  const memesGrid = document.getElementById("memes-grid");
  const memesGridWrapper = document.getElementById("memes-grid-wrapper");
  const memesLoading = document.getElementById("memes-loading");
  const memeSearch = document.getElementById("meme-search") as HTMLInputElement;
  const refreshBtn = document.getElementById("refresh-memes");
  const addTextBoxBtn = document.getElementById("add-text-box");
  const resetTextBoxesBtn = document.getElementById("reset-text-boxes");
  const textBoxesContainer = document.getElementById("text-boxes-container");
  const toggleEditModeBtn = document.getElementById("toggle-edit-mode") as HTMLButtonElement;
  const editHint = document.getElementById("edit-hint");
  const resetPositionsBtn = document.getElementById("reset-positions");

  // Tab elements
  const tabImage = document.getElementById("tab-image");
  const tabText = document.getElementById("tab-text");
  const contentImage = document.getElementById("content-image");
  const contentText = document.getElementById("content-text");

  // Tab switching logic
  function switchTab(showImage: boolean) {
    if (showImage) {
      tabImage?.classList.add("active");
      tabText?.classList.remove("active");
      contentImage?.classList.remove("hidden");
      contentText?.classList.add("hidden");
    } else {
      tabImage?.classList.remove("active");
      tabText?.classList.add("active");
      contentImage?.classList.add("hidden");
      contentText?.classList.remove("hidden");
    }
  }

  tabImage?.addEventListener("click", () => switchTab(true));
  tabText?.addEventListener("click", () => switchTab(false));

  // Global settings
  const globalFontSizeInput = document.getElementById("global-font-size") as HTMLInputElement;
  const globalFontSizeValue = document.getElementById("global-font-size-value");
  const globalStrokeWidthInput = document.getElementById("global-stroke-width") as HTMLInputElement;
  const globalStrokeWidthValue = document.getElementById("global-stroke-width-value");
  const globalTextColorInput = document.getElementById("global-text-color") as HTMLInputElement;

  let currentImg: HTMLImageElement | null = null;
  const allMemes = memesData;
  let editMode = false;
  let draggedTextBox: TextBox | null = null;
  let resizingTextBox: TextBox | null = null;
  let dragOffset = { x: 0, y: 0 };

  interface TextBox {
    id: number;
    text: string;
    x: number;
    y: number;
    fontSize?: number;
    color?: string;
    strokeWidth?: number;
  }

  let textBoxes: TextBox[] = [];
  let nextTextBoxId = 1;

  // Predefined templates
  const memeTemplates: Record<string, TextBox[]> = {
    "181913649": [
      { id: 1, text: "", x: 70, y: 25 },
      { id: 2, text: "", x: 70, y: 75 },
    ],
    "112126428": [
      { id: 1, text: "", x: 20, y: 70 },
      { id: 2, text: "", x: 45, y: 45 },
      { id: 3, text: "", x: 75, y: 55 },
    ],
    "87743020": [
      { id: 1, text: "", x: 25, y: 70 },
      { id: 2, text: "", x: 55, y: 65 },
      { id: 3, text: "", x: 50, y: 15 },
    ],
    "93895088": [
      { id: 1, text: "", x: 30, y: 12 },
      { id: 2, text: "", x: 30, y: 37 },
      { id: 3, text: "", x: 30, y: 62 },
      { id: 4, text: "", x: 30, y: 87 },
    ],
    "438680": [
      { id: 1, text: "", x: 30, y: 25 },
      { id: 2, text: "", x: 75, y: 75 },
    ],
    "129242436": [{ id: 1, text: "", x: 35, y: 65 }],
    "188390779": [
      { id: 1, text: "", x: 25, y: 75 },
      { id: 2, text: "", x: 75, y: 75 },
    ],
    "322841258": [
      { id: 1, text: "", x: 25, y: 25 },
      { id: 2, text: "", x: 75, y: 25 },
      { id: 3, text: "", x: 75, y: 75 },
    ],
    "224015000": [{ id: 1, text: "", x: 50, y: 85 }],
    "27813981": [{ id: 1, text: "", x: 50, y: 90 }],
    "55311130": [{ id: 1, text: "", x: 50, y: 90 }],
    "61520": [
      { id: 1, text: "", x: 50, y: 10 },
      { id: 2, text: "", x: 50, y: 90 },
    ],
    "206151308": [
      { id: 1, text: "", x: 20, y: 50 },
      { id: 2, text: "", x: 50, y: 40 },
      { id: 3, text: "", x: 80, y: 50 },
    ],
    "217743513": [
      { id: 1, text: "", x: 25, y: 35 },
      { id: 2, text: "", x: 75, y: 50 },
    ],
    "124822590": [
      { id: 1, text: "", x: 30, y: 25 },
      { id: 2, text: "", x: 75, y: 55 },
      { id: 3, text: "", x: 50, y: 85 },
    ],
    "131087935": [
      { id: 1, text: "", x: 75, y: 15 },
      { id: 2, text: "", x: 15, y: 65 },
      { id: 3, text: "", x: 35, y: 55 },
      { id: 4, text: "", x: 70, y: 55 },
      { id: 5, text: "", x: 70, y: 80 },
    ],
    "252600902": [
      { id: 1, text: "", x: 40, y: 20 },
      { id: 2, text: "", x: 70, y: 20 },
    ],
    "161865971": [
      { id: 1, text: "", x: 50, y: 25 },
      { id: 2, text: "", x: 50, y: 65 },
    ],
    "135256802": [
      { id: 1, text: "", x: 15, y: 55 },
      { id: 2, text: "", x: 85, y: 55 },
      { id: 3, text: "", x: 50, y: 20 },
    ],
    "97984": [
      { id: 1, text: "", x: 50, y: 15 },
      { id: 2, text: "", x: 50, y: 85 },
    ],
    "131940431": [
      { id: 1, text: "", x: 35, y: 25 },
      { id: 2, text: "", x: 85, y: 25 },
      { id: 3, text: "", x: 35, y: 75 },
      { id: 4, text: "", x: 85, y: 75 },
    ],
    "80707627": [
      { id: 1, text: "", x: 50, y: 25 },
      { id: 2, text: "", x: 50, y: 55 },
      { id: 3, text: "", x: 50, y: 85 },
    ],
    "4087833": [
      { id: 1, text: "", x: 50, y: 25 },
      { id: 2, text: "", x: 50, y: 85 },
    ],
    "102156234": [
      { id: 1, text: "", x: 50, y: 15 },
      { id: 2, text: "", x: 50, y: 85 },
    ],
    "309868304": [
      { id: 1, text: "", x: 25, y: 35 },
      { id: 2, text: "", x: 75, y: 35 },
      { id: 3, text: "", x: 50, y: 15 },
    ],
    "100777631": [
      { id: 1, text: "", x: 20, y: 85 },
      { id: 2, text: "", x: 50, y: 85 },
      { id: 3, text: "", x: 75, y: 30 },
    ],
    "148909805": [
      { id: 1, text: "", x: 75, y: 40 },
      { id: 2, text: "", x: 25, y: 40 },
    ],
    "247375501": [
      { id: 1, text: "", x: 25, y: 85 },
      { id: 2, text: "", x: 75, y: 85 },
      { id: 3, text: "", x: 25, y: 30 },
      { id: 4, text: "", x: 75, y: 30 },
    ],
  };

  function getDefaultTextBoxes(boxCount: number = 2): TextBox[] {
    const boxes: TextBox[] = [];
    for (let i = 0; i < boxCount; i++) {
      let y = 10;
      if (boxCount > 1) {
        y = 10 + (i * 80) / (boxCount - 1);
      }
      boxes.push({ id: nextTextBoxId++, text: "", x: 50, y });
    }
    return boxes;
  }

  function initializeTextBoxes(memeId?: string) {
    textBoxes = [];
    nextTextBoxId = 1;

    if (memeId && memeTemplates[memeId]) {
      textBoxes = memeTemplates[memeId].map((box) => ({ ...box, id: nextTextBoxId++ }));
    } else {
      const meme = allMemes.find((m: any) => m.id === memeId);
      const boxCount = meme?.box_count || 2;
      textBoxes = getDefaultTextBoxes(boxCount);
    }

    renderTextBoxControls();
    drawMeme();
  }

  function renderTextBoxControls() {
    if (!textBoxesContainer) return;

    textBoxesContainer.innerHTML = textBoxes
      .map(
        (box, index) => `
        <div class="text-box-card" data-box-id="${box.id}">
          <div class="flex items-center justify-between mb-1">
            <span class="text-[10px] font-bold tracking-widest text-slate-500 uppercase">Text ${index + 1}</span>
            <button class="remove-text-box text-rose-400 hover:text-rose-300 text-[10px] font-bold uppercase transition-colors" data-box-id="${box.id}">
              ✕
            </button>
          </div>
          <input
            type="text"
            class="text-box-input w-full uppercase"
            style="font-size: 0.75rem; padding: 0.3rem 0.5rem;"
            placeholder="ENTER TEXT"
            data-box-id="${box.id}"
            value="${box.text}"
          />
          <div class="mt-1 text-[9px] font-mono text-slate-600">
            ${Math.round(box.x)}%, ${Math.round(box.y)}%
          </div>
        </div>
      `
      )
      .join("");

    document.querySelectorAll(".text-box-input").forEach((input) => {
      input.addEventListener("input", (e) => {
        const boxId = parseInt((e.target as HTMLElement).dataset.boxId || "0");
        const box = textBoxes.find((b) => b.id === boxId);
        if (box) {
          box.text = (e.target as HTMLInputElement).value;
          drawMeme();
        }
      });

      input.addEventListener("focus", (e) => {
        const boxId = parseInt((e.target as HTMLElement).dataset.boxId || "0");
        highlightTextBox(boxId);
      });
    });

    document.querySelectorAll(".remove-text-box").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        const boxId = parseInt((e.target as HTMLElement).dataset.boxId || "0");
        removeTextBox(boxId);
      });
    });
  }

  function highlightTextBox(boxId: number) {
    document.querySelectorAll(".text-box-card").forEach((card) => {
      card.classList.remove("active");
    });
    const card = document.querySelector(`[data-box-id="${boxId}"]`);
    if (card) {
      card.classList.add("active");
    }
  }

  function addTextBox() {
    textBoxes.push({ id: nextTextBoxId++, text: "", x: 50, y: 50 });
    renderTextBoxControls();
    drawMeme();
  }

  function removeTextBox(boxId: number) {
    textBoxes = textBoxes.filter((b) => b.id !== boxId);
    renderTextBoxControls();
    drawMeme();
  }

  function resetTextBoxes() {
    const currentMemeId = document
      .querySelector(".meme-template.selected")
      ?.getAttribute("data-id");
    initializeTextBoxes(currentMemeId || undefined);
  }

  function displayMemes(memes: any[]) {
    if (!memesGrid || !memesGridWrapper) return;
    if (memesLoading) memesLoading.style.display = "none";
    memesGridWrapper.style.display = "";
    const popularMemes = memes.slice(0, 100);

    memesGrid.innerHTML = popularMemes
      .map(
        (meme) => `
        <div class="meme-template" data-url="${meme.localUrl || meme.url}" data-name="${meme.name}" data-id="${meme.id}">
          <img src="${meme.localUrl || meme.url}" alt="${meme.name}" loading="lazy" />
          <div class="meme-name">${meme.name}</div>
        </div>
      `
      )
      .join("");

    document.querySelectorAll(".meme-template").forEach((template) => {
      template.addEventListener("click", () => {
        const url = (template as HTMLElement).dataset.url;
        const memeId = (template as HTMLElement).dataset.id;
        if (url) {
          loadMemeTemplate(url, memeId);
          document
            .querySelectorAll(".meme-template")
            .forEach((t) => t.classList.remove("selected"));
          template.classList.add("selected");
        }
      });
    });
  }

  memeSearch?.addEventListener("input", (e) => {
    const searchTerm = (e.target as HTMLInputElement).value.toLowerCase();
    if (!searchTerm) {
      displayMemes(allMemes);
      return;
    }
    const filtered = allMemes.filter((meme: any) => meme.name.toLowerCase().includes(searchTerm));
    displayMemes(filtered);
  });

  refreshBtn?.addEventListener("click", () => displayMemes(allMemes));

  function loadMemeTemplate(url: string, memeId?: string) {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      currentImg = img;
      initializeTextBoxes(memeId);
    };
    img.onerror = () => {
      const img2 = new Image();
      img2.onload = () => {
        currentImg = img2;
        initializeTextBoxes(memeId);
      };
      img2.src = url;
    };
    img.src = url;
  }

  function renderMeme(
    targetCtx: CanvasRenderingContext2D,
    targetCanvas: HTMLCanvasElement,
    showEditHandles: boolean
  ) {
    if (!currentImg) return;
    const maxWidth = 800;
    const ratio = currentImg.width / currentImg.height;
    targetCanvas.width = Math.min(currentImg.width, maxWidth);
    targetCanvas.height = targetCanvas.width / ratio;
    targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
    targetCtx.drawImage(currentImg, 0, 0, targetCanvas.width, targetCanvas.height);

    textBoxes.forEach((box) => {
      const fontSize = box.fontSize || parseInt(globalFontSizeInput.value);
      const strokeWidth = box.strokeWidth || parseInt(globalStrokeWidthInput.value);
      const color = box.color || globalTextColorInput.value;

      targetCtx.fillStyle = color;
      targetCtx.strokeStyle = "black";
      targetCtx.lineWidth = strokeWidth;
      targetCtx.textAlign = "center";
      targetCtx.font = `bold ${fontSize}px Impact, Arial Black, sans-serif`;
      targetCtx.lineJoin = "round";
      targetCtx.textBaseline = "middle";

      const x = (box.x / 100) * targetCanvas.width;
      const y = (box.y / 100) * targetCanvas.height;

      if (box.text) {
        for (let i = 0; i < 3; i++) targetCtx.strokeText(box.text.toUpperCase(), x, y);
        targetCtx.fillText(box.text.toUpperCase(), x, y);
      }

      if (showEditHandles) {
        targetCtx.save();
        const metrics = targetCtx.measureText(box.text.toUpperCase() || "TEXT " + box.id);
        const height = fontSize * 1.2;
        const width = Math.max(metrics.width + 20, 100);
        const top = y - height / 2;
        const left = x - width / 2;
        targetCtx.strokeStyle = draggedTextBox?.id === box.id ? "#6366f1" : "rgba(255,255,255,0.4)";
        targetCtx.lineWidth = 2;
        targetCtx.setLineDash([5, 5]);
        targetCtx.strokeRect(left, top, width, height);
        targetCtx.fillStyle = draggedTextBox?.id === box.id ? "#6366f1" : "white";
        targetCtx.fillRect(left + width - 6, top + height - 6, 12, 12);
        targetCtx.restore();
      }
    });
  }

  function drawMeme() {
    if (!ctx || !currentImg) return;
    renderMeme(ctx, canvas, editMode);
  }

  toggleEditModeBtn?.addEventListener("click", () => {
    editMode = !editMode;
    toggleEditModeBtn.classList.toggle("bg-indigo-600", editMode);
    canvas.classList.toggle("edit-mode", editMode);
    editHint?.classList.toggle("hidden", !editMode);
    if (editMode) setTimeout(() => editHint?.classList.add("hidden"), 3000);
    drawMeme();
  });

  canvas.addEventListener("mousedown", (e) => {
    if (!editMode || !ctx) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const clickX = (e.clientX - rect.left) * scaleX;
    const clickY = (e.clientY - rect.top) * scaleY;

    for (let i = textBoxes.length - 1; i >= 0; i--) {
      const box = textBoxes[i];
      const fontSize = box.fontSize || parseInt(globalFontSizeInput.value);
      const x = (box.x / 100) * canvas.width;
      const y = (box.y / 100) * canvas.height;
      ctx.font = `bold ${fontSize}px Impact, Arial Black, sans-serif`;
      const metrics = ctx.measureText(box.text.toUpperCase() || "TEXT " + box.id);
      const height = fontSize * 1.2;
      const width = Math.max(metrics.width + 20, 100);
      const top = y - height / 2;
      const left = x - width / 2;
      const hSize = 20;

      if (Math.abs(clickX - (left + width)) < hSize && Math.abs(clickY - (top + height)) < hSize) {
        resizingTextBox = box;
        highlightTextBox(box.id);
        return;
      }
      if (clickX >= left && clickX <= left + width && clickY >= top && clickY <= top + height) {
        draggedTextBox = box;
        dragOffset = { x: clickX - x, y: clickY - y };
        highlightTextBox(box.id);
        drawMeme();
        return;
      }
    }
  });

  window.addEventListener("mousemove", (e) => {
    if (!draggedTextBox && !resizingTextBox) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const moveX = (e.clientX - rect.left) * scaleX;
    const moveY = (e.clientY - rect.top) * scaleY;

    if (draggedTextBox) {
      draggedTextBox.x = ((moveX - dragOffset.x) / canvas.width) * 100;
      draggedTextBox.y = ((moveY - dragOffset.y) / canvas.height) * 100;
      renderTextBoxControls();
    } else if (resizingTextBox) {
      const x = (resizingTextBox.x / 100) * canvas.width;
      const dist = Math.sqrt(
        Math.pow(moveX - x, 2) + Math.pow(moveY - (resizingTextBox.y / 100) * canvas.height, 2)
      );
      resizingTextBox.fontSize = Math.max(10, Math.min(200, dist * 0.8));
    }
    drawMeme();
  });

  window.addEventListener("mouseup", () => {
    draggedTextBox = null;
    resizingTextBox = null;
    drawMeme();
  });

  imageUpload?.addEventListener("change", (e) => {
    const file = (e.target as HTMLInputElement).files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          currentImg = img;
          initializeTextBoxes();
        };
        img.src = event.target?.result as string;
      };
      reader.readAsDataURL(file);
    }
  });

  globalFontSizeInput?.addEventListener("input", (e) => {
    const val = (e.target as HTMLInputElement).value;
    if (globalFontSizeValue) globalFontSizeValue.textContent = val;
    textBoxes.forEach((b) => (b.fontSize = parseInt(val)));
    drawMeme();
  });

  globalStrokeWidthInput?.addEventListener("input", (e) => {
    const val = (e.target as HTMLInputElement).value;
    if (globalStrokeWidthValue) globalStrokeWidthValue.textContent = val;
    textBoxes.forEach((b) => (b.strokeWidth = parseInt(val)));
    drawMeme();
  });

  globalTextColorInput?.addEventListener("input", drawMeme);
  resetPositionsBtn?.addEventListener("click", () => {
    textBoxes.forEach((b, i) => {
      b.x = 50;
      b.y = 10 + (i * 80) / (textBoxes.length - 1 || 1);
    });
    renderTextBoxControls();
    drawMeme();
  });

  addTextBoxBtn?.addEventListener("click", addTextBox);
  resetTextBoxesBtn?.addEventListener("click", resetTextBoxes);

  downloadBtn?.addEventListener("click", () => {
    if (!currentImg) return;
    renderMeme(ctx!, canvas, false);
    const link = document.createElement("a");
    link.download = `meme-${Date.now()}.png`;
    link.href = canvas.toDataURL("image/png");
    link.click();
    drawMeme();
  });

  // Initial load
  displayMemes(allMemes);
  loadMemeTemplate(allMemes[0].localUrl || allMemes[0].url, allMemes[0].id);
</script>
